###
# CoffeeDoc example documentation #

This is a module-level docstring, and will be displayed at the top of the module documentation.
Documentation generated by [CoffeeDoc](http://github.com/omarkhan/coffeedoc)
###
# console.log 'facade',ConveyorFacade
class ConveyorModel extends ConveyorBase
  ###
  This docstring documents MyClass. It can include *Markdown* syntax,
  which will be converted to html.
  ###
  # @data: test: true
  @_refCount = 0
  # facade: ConveyorFacade
  @facade: ConveyorFacade
  deleted: false
  constructor: (data,conf)->
    @_ref = @constructor._refCount++
    @data = {}
    @conf = ConveyorUtil.obj conf
    @interfaces = {}
    # console.log @
    @sync(data)

  fetch: (opts)->
    if opts?.tmp?
      tmp = ConveyorUtil.obj opts.tmp
      delete opts.tmp
    else
      tmp = {}
    opts = ConveyorUtil.extend {}, @conf, opts
    t_opts = ConveyorUtil.extend {}, opts, tmp
    data = @$publish(opts.changed_only && true || false)
    console.info 'fetch opts',t_opts, @conf
    if @getPrimaryKey()
      @allInterfaces('fetch', data, t_opts).then (data)=>
        @sync data[0], opts
      , ->
        # console.log 'Failed fetching'
    else
      throw "Cannot reload without a primary key"
  save: (opts)->
    if opts?.tmp?
      tmp = ConveyorUtil.obj opts.tmp
      delete opts.tmp
    else
      tmp = {}
    opts = ConveyorUtil.extend {}, @conf, opts
    t_opts = ConveyorUtil.extend {}, opts, tmp
    data = @$publish(opts.changed_only && true || false)
    if @getPrimaryKey()
      @allInterfaces('save', data, t_opts).then (data)=>
        @sync data[0], opts
    else
      @allInterfaces('create', data, t_opts).then (data)=>
        @sync data[0], opts
  remove: (opts)->
    opts = ConveyorUtil.extend {}, @conf, opts
    data = @$publish(opts.changed_only && true || false)
    if @getPrimaryKey()
      @allInterfaces('remove', data, opts).then (data)=>
        @deleted = true
    else
      throw "no primary key, can't delete"
  getPrimaryKey: ->
    @get @constructor.primaryKey
  @list: (args, conf)->
    conf = {} if typeof conf isnt 'object'
    conf.data = args
    if conf.tmp?
      tmp = ConveyorUtil.obj conf.tmp
      delete conf.tmp
    else
      tmp = {}
    t_conf = ConveyorUtil.extend {}, conf, tmp
    # returns a conveyor belt
    @firstInterface('list', t_conf).then (arr)=>
      # console.log 'interface got',arr
      out = []
      # console.info arr
      for item in arr
        out.push @sync item, conf
      hm = @_collectionize out

  @get: (pk,conf)->
    promise = new ConveyorPromise
    if typeof pk is 'object'
      promise.resolve @sync data, conf
    else if typeof pk is 'number'
      if @index["#{@name}_#{pk}"]
        promise.resolve @index["#{@name}_#{pk}"]
      else
        conf = ConveyorUtil.obj conf
        conf.params = ConveyorUtil.obj conf.params
        conf.params.id = pk
        @firstInterface('fetch', conf).then (obj)=>
          promise.resolve @sync obj, conf
        , (err)->
          promise.reject err
    else
      promise.reject("invalid model ref")
    return promise

  @sync: (data,conf)->
    pk = data[@primaryKey]
    if not pk
      throw "You can only sync models with a primary key."
    if not @index["#{@name}_#{pk}"]?
      return @index["#{@name}_#{pk}"] = new @$self data, conf
    else
      return @index["#{@name}_#{pk}"].sync data, conf
  sync: (data,opts)->
    data = ConveyorUtil.obj data
    ConveyorUtil.extend @conf, opts
    force = data[@constructor.primaryKey]?
    for key of @fields
      conf = @fields[key]
      continue if not data[key]?
      val = data[key]
      if @data[key]? and @data[key] instanceof ConveyorValueCore
        @data[key].set val, true
      else if conf?.type?
        if conf.type instanceof ConveyorValueCore
          @data[key] = new conf.type(val, key, @, conf, force)
        else if ConveyorValue[conf.type]?
          @data[key] = new ConveyorValue[conf.type](val,key,@,conf, force)
        else
          console.error 'ConveyorModelValue::'+conf.type+' is not a valid value type.'

      if not @data[key]?
        console.warn 'ConveyorModel::constructor ignoring key: ',key,data[key]
    @
  $publish: (changed=false)->
    out = {}
    for key of @data
      if changed
        if @data[key].dirty
          out[key] = @data[key].$publish()
      else
        out[key] = @data[key].$publish()
    out
  val: (key)->
    if @data[key]
      return @data[key]
    else
      return null
  get: (key)->
    if @data[key]
      return @data[key].get()
    else
      return null
  set: (key,value,force=false)->
    if @data[key]
      return @data[key].set(value,force)
    else if @fields[key]?
      conf = @fields[key]
      if conf.type instanceof ConveyorValueCore
        @data[key] = new conf.type(value,key,@,conf,force)
      else if ConveyorValue[conf.type]?
        @data[key] = new ConveyorValue[conf.type](value,key,@,conf,force)
      else
        console.error 'ConveyorModelValue::'+conf.type+' is not a valid value type.'
  $facade: (tr)->
    # console.log @constructor.facade
    new @constructor.facade @, tr
  $isDirty: ()->
    for item of @data
      if @data[item].dirty
        return true
    return false
  reset: ()->
    for item of @data
      if @data[item].dirty
        do @data[item].reset
    # return false
  @_collectionize: (arr)->
    arr.$changed = ->
      @.filter (model)->
        model.dirty
    out = []
    me = @
    arr.$facade = (tr)->
      out = []

      out.$json = ->
        rout = []
        for x in @
          rout.push x.$json()
        rout
      for i in @
        out.push new me.facade i, tr
      out
    arr

  @create: (params)->
  @addInterface: (name,$interface)->
    @interfaces[name] = $interface;
  addInterface: (name,$interface)->
    @constructor.interfaces[name] = $interface;

  allInterfaces: (action, args...)->
    interfaces = ConveyorUtil.obj @constructor.interfaces
    all = []
    for x of interfaces
      $intfc = interfaces[x]
      if $intfc.actions.indexOf(action) isnt -1
        all.push $intfc.$$apply action, args
    if not all.length
      throw "No interface available with the ability to: #{action}"
    ConveyorPromise.aggregate all

  @firstInterface: (action,args...)->
    for x of @interfaces
      $intfc = @interfaces[x]
      if $intfc.actions.indexOf(action) isnt -1
        return $intfc.$$apply action, args
    throw "No interface available with the ability to: #{action}"


  fields: {}
  @primaryKey: 'id'
  @index: {}



root = exports ? window
root.ConveyorModel = ConveyorModel
